// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by the Google Gen AI SDK generator DO NOT EDIT.

package genai

import (
	"context"
	"fmt"
	"mime"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
)

func fileStatusToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromDetails := getValueByPath(fromObject, []string{"details"})
	if fromDetails != nil {
		setValueByPath(toObject, []string{"details"}, fromDetails)
	}

	fromMessage := getValueByPath(fromObject, []string{"message"})
	if fromMessage != nil {
		setValueByPath(toObject, []string{"message"}, fromMessage)
	}

	fromCode := getValueByPath(fromObject, []string{"code"})
	if fromCode != nil {
		setValueByPath(toObject, []string{"code"}, fromCode)
	}

	return toObject, nil
}

func fileToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromName := getValueByPath(fromObject, []string{"name"})
	if fromName != nil {
		setValueByPath(toObject, []string{"name"}, fromName)
	}

	fromDisplayName := getValueByPath(fromObject, []string{"displayName"})
	if fromDisplayName != nil {
		setValueByPath(toObject, []string{"displayName"}, fromDisplayName)
	}

	fromMimeType := getValueByPath(fromObject, []string{"mimeType"})
	if fromMimeType != nil {
		setValueByPath(toObject, []string{"mimeType"}, fromMimeType)
	}

	fromSizeBytes := getValueByPath(fromObject, []string{"sizeBytes"})
	if fromSizeBytes != nil {
		setValueByPath(toObject, []string{"sizeBytes"}, fromSizeBytes)
	}

	fromCreateTime := getValueByPath(fromObject, []string{"createTime"})
	if fromCreateTime != nil {
		setValueByPath(toObject, []string{"createTime"}, fromCreateTime)
	}

	fromExpirationTime := getValueByPath(fromObject, []string{"expirationTime"})
	if fromExpirationTime != nil {
		setValueByPath(toObject, []string{"expirationTime"}, fromExpirationTime)
	}

	fromUpdateTime := getValueByPath(fromObject, []string{"updateTime"})
	if fromUpdateTime != nil {
		setValueByPath(toObject, []string{"updateTime"}, fromUpdateTime)
	}

	fromSha256Hash := getValueByPath(fromObject, []string{"sha256Hash"})
	if fromSha256Hash != nil {
		setValueByPath(toObject, []string{"sha256Hash"}, fromSha256Hash)
	}

	fromUri := getValueByPath(fromObject, []string{"uri"})
	if fromUri != nil {
		setValueByPath(toObject, []string{"uri"}, fromUri)
	}

	fromDownloadUri := getValueByPath(fromObject, []string{"downloadUri"})
	if fromDownloadUri != nil {
		setValueByPath(toObject, []string{"downloadUri"}, fromDownloadUri)
	}

	fromState := getValueByPath(fromObject, []string{"state"})
	if fromState != nil {
		setValueByPath(toObject, []string{"state"}, fromState)
	}

	fromSource := getValueByPath(fromObject, []string{"source"})
	if fromSource != nil {
		setValueByPath(toObject, []string{"source"}, fromSource)
	}

	fromVideoMetadata := getValueByPath(fromObject, []string{"videoMetadata"})
	if fromVideoMetadata != nil {
		setValueByPath(toObject, []string{"videoMetadata"}, fromVideoMetadata)
	}

	fromError := getValueByPath(fromObject, []string{"error"})
	if fromError != nil {
		fromError, err = fileStatusToMldev(ac, fromError.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"error"}, fromError)
	}

	return toObject, nil
}

func createFileParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromFile := getValueByPath(fromObject, []string{"file"})
	if fromFile != nil {
		fromFile, err = fileToMldev(ac, fromFile.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"file"}, fromFile)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func createFileResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromHttpHeaders := getValueByPath(fromObject, []string{"httpHeaders"})
	if fromHttpHeaders != nil {
		setValueByPath(toObject, []string{"httpHeaders"}, fromHttpHeaders)
	}

	return toObject, nil
}

type Files struct {
	apiClient *apiClient
}

func (m Files) create(ctx context.Context, file *File, config *CreateFileConfig) (*CreateFileResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"file": file, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}
	var response = new(CreateFileResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {

		return nil, fmt.Errorf("method Create is only supported in the Gemini API client. You can choose to use Gemini API by setting ClientConfig.Backend to BackendGeminiAPI.")

	} else {
		toConverter = createFileParametersToMldev
		fromConverter = createFileResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("None", urlParams)
	} else {
		path, err = formatMap("upload/v1beta/files", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

// Calls the API to upload a file using a supported file service.
func (m Files) Upload(ctx context.Context, file string, config *UploadFileConfig) (*File, error) {
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		return nil, fmt.Errorf("This method is only supported in the Gemini Developer client.")
	}

	var fileToUpload File
	if config != nil {
		fileToUpload.MIMEType = config.MIMEType
		fileToUpload.Name = config.Name
		fileToUpload.DisplayName = config.DisplayName
	}

	if fileToUpload.Name != "" && !strings.HasPrefix(fileToUpload.Name, "files/") {
		fileToUpload.Name = "files/" + fileToUpload.Name
	}

	fileInfo, err := os.Stat(file)
	if err != nil || fileInfo.IsDir() {
		return nil, fmt.Errorf("%s is not a valid file path.", file)
	}

	fileToUpload.SizeBytes = Ptr[int64](fileInfo.Size())

	if fileToUpload.MIMEType == "" {
		fileToUpload.MIMEType = mime.TypeByExtension(filepath.Ext(file))
		if fileToUpload.MIMEType == "" {
			return nil, fmt.Errorf("Unknown mime type: Could not determine the mimetype for your file please set the `MIMEType` argument")
		}
	}

	httpOptions := HTTPOptions{Headers: http.Header{}}
	if config != nil && config.HTTPOptions != nil {
		httpOptions = *config.HTTPOptions
	}

	httpOptions.APIVersion = ""
	httpOptions.Headers.Add("Content-Type", "application/json")
	httpOptions.Headers.Add("X-Goog-Upload-Protocol", "resumable")
	httpOptions.Headers.Add("X-Goog-Upload-Command", "start")
	httpOptions.Headers.Add("X-Goog-Upload-Header-Content-Length", strconv.FormatInt(*fileToUpload.SizeBytes, 10))
	httpOptions.Headers.Add("X-Goog-Upload-Header-Content-Type", fileToUpload.MIMEType)

	var createFileConfig CreateFileConfig
	createFileConfig.HTTPOptions = &httpOptions

	resp, err := m.create(ctx, &fileToUpload, &createFileConfig)
	if err != nil {
		return nil, fmt.Errorf("Failed to create file. Ran into an error: %s", err)
	}
	if resp.HTTPHeaders == nil || resp.HTTPHeaders.Get("x-goog-upload-url") == "" {
		return nil, fmt.Errorf("Failed to create file. Upload URL was not returned from the create file request.")
	}

	uploadURL := resp.HTTPHeaders.Get("x-goog-upload-url")
	return m.apiClient.uploadFileFromPath(ctx, file, uploadURL, *fileToUpload.SizeBytes, &httpOptions)
}
